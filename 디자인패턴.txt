---------- 실전 자바 디자인 패턴 ----------

1) 객체 지향
  1. 클래스
    객체와 인스턴스 : 클래스에서 객체를 만드는 프로스세스를 클래스 인스턴스화(instantiate) 라고 하며, 클래스에서 생성된 객체를 해당 클래스의 인스턴스(instance)라고 한다.
    
    클래스 정의 : 클래스에는 생성자와 멤버변수, 메서드가 있다.

    접근 제어자 : 클래스 멤버의 접근 권한을 지정하는 키워드로 public, protected, private 를 제공한다.
                  접근 제어자를 생략하면 기본적으로 default이다
                  public으로 지정된 멤버는 클래스 밖에서 자유롭게 접근할 수 있다.
                  클래스 멤버가 protected 로 지정되면 해당 클래스나 자식 클래스에서 접근할 수 있다.
                  클래스 멤버가 private 으로 지정되면 해당 클래스에서만 접근할 수 있다.

    클래스 멤버변수와 메서드
      클래스 멤버 변수와 메서드에 static 키워드를 사용하여 만든다
      이 클래스로 만들어진 모든 인스턴스에 공유되기 때문에 인스턴스를 만들지 않아도 클래스 멤버에 접근할 수 있다.

  2. 클래스 상속

  3. 오버라이딩과 오버로딩  //어느정도 아니깐 대충 검색으로 알아보자 여기설명은 빈약
    
  4. 추상 클래스 
    추상클래슨느 구현 메서드와 추상 메서드가 동시에 존재할 수 있다.
    구현메서드는 실제 구현 내용을 포함한 메서드이다.
    추상메서드는 선언만 된 메서드이다.
    추상 클래스는 구현 내용이 없는 추상 메서드를 포함하기 때문에 불완전한 클래스이다.
    추상클래스는 단독으로 객체를 생성할 수 없고 추상 클래스를 상속하고 구현 내용을 추가하는 자식 클래스를 통해 객체를 생성한다.

    정의 : abstract 키워드를 클래스 선언 앞에 붙여서 선언한다.
            추상 메서드를 선언할 때도 abstract 키워드를 사용한다.


  5. 인터페이스
    자신 인터페이스는 여러 부모 인터페이스를 다중 상속할 수 있다.

    인터페이스에서 선언한 메서드를 모두 재정의해야 한다.





위에꺼는 다필요없는거같고 나중에 삭제하자
객체지향 설계 원칙   S.O.L.I.D 공부하자
  1. 단일 책임 원칙
  2. 개방 폐쇄 원칙
  3. 리스코프 치환 원칙
  4. 인터페이스 분리 원칙
  5. 의존 역전 원칙

생성패턴
  1. 싱글톤
  2. 빌더
  3. 팩토리메서드
  4. 프로토타입
  5. 추상팩토리

구조패턴
  1. 어댑터
  2. 브리지
  3. 컴포지트
  4. 데커레이터
  5. 퍼사드
  6. 플라이웨이트
  7. 프록시

행위패턴
  1. 책임연쇄
  2. 커맨드
  3. 인터프리터
  4.이터레이터
  5. 미디에이터
  6. 메멘토
  7. 옵저버
  8. 스테이트
  9. 스트래티지
  10. 템플릿 메서드
  11. 비지터

모던 자바 패턴
1. 제네릭스
2. Enums
3. Annotation
4. Functional Interface
5. Stream

공부해보자4




----- 1일1 SOLID & 디자인패턴 적고 지우기 -----
SOLID

SRP 단일책임원칙
클래스는 단하나의 책임을 가져야하며 변경되는 이유는 단하나여야 한다

클래스가 두개이상의 책임을 가지게 되면 목적이 모호해지고 수정을할때 영향을 받는 범위도 커져 유지보수가 힘들어진다.

OCP 개방폐쇄원칙
클래스는 확장에는 열려있고 수정에는 닫혀있어야 한다.

개발작업에 이용된 많은 모듈중에 하나를 수정할때 이와 연관되어있는 모듈들을 줄줄이 수정해야한다면 이와같은 프로그램은 수정하기 어렵다
개방폐쇄원칙은 시스템의 재조직(리팩토링)을 통해 이러한 수정으로인해 더이상의 수정을 유발하지 않도록하는 것이다.
개방 폐쇄원칙을 잘적용한 시스템은 기능의 수정이나 추가를 할때 기존잘 동작하고 있던 코드에 새로운 코드를 추가함으로써 기능의 추가나 수정이 가능하다

LSP 리스코프 치환원칙
상위타입의 객체를 하위타입으로 바꾸어도 프로그램은 일관되게 동작해야한다.














########## 디자인패턴 ##########
생성패턴  FAPBS
  ㄴ> 객체의 생성과 조합을 캡슐화해 특정객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공


Factory Method 패턴
  상위클래스에서 알고리즘의 골격을 정하고 하위클래스에서 구체적인 객체생성을 하는 패턴

  장점: 객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮춤.
      코드에 변경이 필요할 시, 객체 생성 클래스만 수정하면 된다.

  인터페이스를 바탕으로 유연성과 확장성이 뛰어난 코드 제작이 가능
  객체의 자료형이 하위 클래스 의해서 결정됨
      확장에 용이함
      상위 클래스에서 그 객체에 대한 정확한 타입을 몰라도 된다.
  SOLID 원칙 중 DIP 의존관계 역전원칙을 성립함


  단점: 새로 생성할 객체의 종류가 늘어날 때마다, 클래스가 많아짐

  
Abtract Factory 패턴
다양한 구성요소(Product)별로 '객체의 집합'(Factory)를 생성할 때 유용
서로 관련있는 객체들을 묶어 팩토리 클래스로 만든 후 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴

구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴

연관된 일련의 객체들을 일관된 방식으로 생성해야하는 경우

새로 생성할 객체의 종류가 늘어날 때마다, 클래스가 많아짐


ProtoType 패턴
클래스가 아닌 기존의 객체(원형객체)로 부터 자신과 똑같은 객체를 생성하는 패턴

런타임에 또 다른 객체를 생성하는것
생성할 객체들의 타입은prototype의 인스턴스로부터 결정,
인스턴스는 새 객체를 생성하기 위해 자기 자신을 복제(clone-깊은복사), 생성 비용이 비쌀 경우 유용함

얕은복사 & 깊은 복사가 있는데 
얕은복사 : =로 대입해서 넣었을 때, 참조타입의 경우 동일 주소값을 가져가게됨
깊은복사 : clone()을 이용하여 가지고 있는 값을 복사, 같은 값이지만 다른 주소값을 가져가게됨






























